<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Snake</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #0a0a0a;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    font-family: 'Courier New', monospace;
    color: #eee;
    overflow: hidden;
  }
  canvas {
    border: 2px solid #333;
    border-radius: 4px;
    background: #111;
  }
  .hud {
    display: flex;
    justify-content: space-between;
    width: 400px;
    padding: 12px 4px;
    font-size: 16px;
    letter-spacing: 1px;
  }
  .score { color: #3BD5AE; }
  .high { color: #888; }
  .overlay {
    position: absolute;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
    color: #ccc;
    font-size: 18px;
  }
  .overlay span { font-size: 13px; color: #666; }
  .overlay .title { font-size: 32px; color: #3BD5AE; letter-spacing: 3px; }
</style>
</head>
<body>

<div class="hud">
  <div class="score">SCORE: <span id="score">0</span></div>
  <div class="high">BEST: <span id="high">0</span></div>
</div>
<canvas id="game" width="400" height="400"></canvas>
<div class="overlay" id="overlay">
  <div class="title">SNAKE</div>
  <div>Press any arrow key to start</div>
  <span>← ↑ ↓ →</span>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');
const scoreEl = document.getElementById('score');
const highEl = document.getElementById('high');

const GRID = 20;
const COLS = canvas.width / GRID;
const ROWS = canvas.height / GRID;
const TICK_MS = 100;

let snake, dir, nextDir, food, score, highScore, running, gameOver;

highScore = +(localStorage.getItem('snake_high') || 0);
highEl.textContent = highScore;

function init() {
  const mid = Math.floor(COLS / 2);
  snake = [{ x: mid, y: Math.floor(ROWS / 2) }];
  dir = { x: 0, y: 0 };
  nextDir = { x: 0, y: 0 };
  score = 0;
  scoreEl.textContent = 0;
  running = false;
  gameOver = false;
  placeFood();
  draw();
  overlay.style.display = 'flex';
}

function placeFood() {
  const occupied = new Set(snake.map(s => `${s.x},${s.y}`));
  let pos;
  do {
    pos = { x: Math.floor(Math.random() * COLS), y: Math.floor(Math.random() * ROWS) };
  } while (occupied.has(`${pos.x},${pos.y}`));
  food = pos;
}

function update() {
  dir = { ...nextDir };
  const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };

  // wall collision
  if (head.x < 0 || head.x >= COLS || head.y < 0 || head.y >= ROWS) return die();
  // self collision
  if (snake.some(s => s.x === head.x && s.y === head.y)) return die();

  snake.unshift(head);

  if (head.x === food.x && head.y === food.y) {
    score++;
    scoreEl.textContent = score;
    if (score > highScore) {
      highScore = score;
      highEl.textContent = highScore;
      localStorage.setItem('snake_high', highScore);
    }
    placeFood();
  } else {
    snake.pop();
  }
}

function die() {
  gameOver = true;
  running = false;
  overlay.innerHTML = `
    <div class="title">GAME OVER</div>
    <div>Score: ${score}</div>
    <span>Press any arrow key to restart</span>
  `;
  overlay.style.display = 'flex';
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // grid dots
  ctx.fillStyle = '#1a1a1a';
  for (let x = 0; x < COLS; x++)
    for (let y = 0; y < ROWS; y++)
      ctx.fillRect(x * GRID + GRID / 2 - 0.5, y * GRID + GRID / 2 - 0.5, 1, 1);

  // food
  ctx.fillStyle = '#e74c3c';
  ctx.shadowColor = '#e74c3c';
  ctx.shadowBlur = 8;
  roundRect(food.x * GRID + 2, food.y * GRID + 2, GRID - 4, GRID - 4, 4);
  ctx.shadowBlur = 0;

  // snake
  snake.forEach((seg, i) => {
    const t = i / snake.length;
    ctx.fillStyle = i === 0 ? '#3BD5AE' : lerpColor('#3BD5AE', '#134A45', t);
    ctx.shadowColor = i === 0 ? '#3BD5AE' : 'transparent';
    ctx.shadowBlur = i === 0 ? 6 : 0;
    roundRect(seg.x * GRID + 1, seg.y * GRID + 1, GRID - 2, GRID - 2, 4);
  });
  ctx.shadowBlur = 0;
}

function roundRect(x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
  ctx.fill();
}

function lerpColor(a, b, t) {
  const pa = [parseInt(a.slice(1,3),16), parseInt(a.slice(3,5),16), parseInt(a.slice(5,7),16)];
  const pb = [parseInt(b.slice(1,3),16), parseInt(b.slice(3,5),16), parseInt(b.slice(5,7),16)];
  const r = Math.round(pa[0] + (pb[0]-pa[0]) * t);
  const g = Math.round(pa[1] + (pb[1]-pa[1]) * t);
  const bl = Math.round(pa[2] + (pb[2]-pa[2]) * t);
  return `rgb(${r},${g},${bl})`;
}

// game loop
let lastTick = 0;
function loop(timestamp) {
  if (running) {
    if (timestamp - lastTick >= TICK_MS) {
      update();
      if (!gameOver) draw();
      lastTick = timestamp;
    }
  }
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// controls
document.addEventListener('keydown', e => {
  const arrows = { ArrowUp: {x:0,y:-1}, ArrowDown: {x:0,y:1}, ArrowLeft: {x:-1,y:0}, ArrowRight: {x:1,y:0} };
  const nd = arrows[e.key];
  if (!nd) return;
  e.preventDefault();

  if (!running && !gameOver) {
    nextDir = nd;
    dir = nd;
    running = true;
    overlay.style.display = 'none';
    lastTick = performance.now();
    return;
  }

  if (gameOver) {
    init();
    nextDir = nd;
    dir = nd;
    running = true;
    overlay.style.display = 'none';
    lastTick = performance.now();
    return;
  }

  // prevent 180° turn
  if (nd.x !== -dir.x || nd.y !== -dir.y) {
    nextDir = nd;
  }
});

init();
</script>
</body>
</html>
